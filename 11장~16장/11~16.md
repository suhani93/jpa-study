# 스프링 컨테이너의 기본 전략 

> 스프링 컨테이너는 트랜잭션을 시작할 때 영속성 컨텍스트를 생성하고 트랜잭션이 끝날 때 영속성 컨텍스트를 종료하는 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용한다.
>
> 띠라서 같은 트랜잭션 안에서는 항상 같은 영속성 컨텍스트에 접근한다.

![1](https://user-images.githubusercontent.com/73545607/131148367-0f8bfb7d-7b27-4696-bbf4-71b9e45fca5b.png)



# 준영속 상태에서의 지연 로딩

> 스프링 컨테이너의 기본 전략으로 인해 트랜잭션 밖에서 지연 로딩 된 entity 객체를 사용하려고 하면 예외가 발생한다. ( 보통 Service Layer에서 트랜잭션을 걸기에 Controller 단에서 발생 )
>
> 이런 문제를 해결하기 위해서는 fetch join 으로 미리 로딩을 하거나 OSIV 를 사용해서 엔티티를 항상 영속 상태로 유지하는 방법이 있다.



# OSIV ( open session in view )

> 영속성 컨텍스트를 뷰까지 열어둔다는 뜻이다.
>
> 이 방법을 사용하면 컨트롤러나 뷰 같은 프리젠테이션 계층이 엔티티를 변경할 수 있어 변경감지로 인해 DB 값이 조작이 될 수 있다.
>
> 이 문제를 해결하기 위해 엔티티를 읽기 전용 인터페이스를 제공, 엔티티를 래핑, DTO로 변환 후 반환이 있는데 애초에 Transaction이 걸려있는 Service Layer에서 해결하고 Controller 단에서는 DTO로 변환된 객체를 넘겨주는게 좋은것 같다.

![2](https://user-images.githubusercontent.com/73545607/131148384-681927f4-f151-42b5-9b4c-645bc33c70c5.png)


# JPA의 컬렉션 객체

> 하이버네이트는 엔티티를 영속 상태로 만들 때 컬렉션 필드를 하이버네이트에서 준비한 래핑 클래스로 감싸서 사용한다.



# Collection, List

> Collection, List는 엔티티를 추가할 때 중복된 엔티티가 있는지 비교하지 않고 단순히 저장한다. 
>
> 따라서 엔티티를 추가해도 지연 로딩된 컬렉션을 초기화하지 않는다.



# Set

> HashSet은 중복을 허용하지 않으므로 add() 메소드로 객체를 추가할 때 마다 equals() , hashcode()메소드로 같은 객체가 있는지 비교한다. 
>
> 같은 객체가 없으면 객체를 추가하고 true를 반환하고, 같은 객체가 이미 있어서 추가에 실패하면 false를 반환한다. 
>
> Set은 엔티티를 추가할 때 중복된 엔티티가 있는지 비교해야 하기에 지연 로딩된 컬렉션을 초기화한다.



# 순서 보장 컬렉션

## List + @OrderColumn

> List에 순서가 있는 값을 저장해서 조회하여 사용한다. -> 여러가지 치명적인 단점이 있어 잘 안사용한다.



## @OrderBy

> 컬렉션 객체 위에 @OrderBy("username desc, id asc")  방식으로 사용하며 @OrderBy를 적용하면 Set의 경우 LinkedHashSet을 사용하게 된다.





# 데이트 형태 컨버팅

> @Converter 사용하여 데이터 값을 컨버팅해서 저장 할 수 있다.



# JPA 예외 변환

> 스프링 프레임워크에서 데이터 접근 계층에 대한 예외를 추상화해서 개발자에게 제공해준다. (PersistenceExceptionTranslationPostProcessor)
>
> 이로 인하여 공통화 된 예외 처리가 가능하다.



# 엔티티 비교

> 영속성 컨텍스트가 같은 경우 아래의 경우가 참이다.
>
> - 동일성( == ) 
> - 동등성( equals )
> - DB 동등성 ( @Id )
>
> 영속성 컨텍스트가 다른 경우 아래의 경우가 참이다.
>
> - 동등성 ( equals )
> - DB 동등성 ( @Id )



# 프록시 객체 비교 ( 지연 로딩 된 객체 )

> 프록시는 원본 엔티티를 상속받아서 만들어지므로 프록시로 조회한 엔티티의 타입을 비교할 때는 == 비교를 하면 안되고 대신 instanceof를 사용해야 한다



# N + 1 문제

> 지연 로딩 시 발생하는 문제로 심각한 성능 저하가 발생되는 원인이다.
>
> 해결 방법으로는 몇가지가 있다.
>
> - fetch join
> - Batch Size 조정
> - fetch mode 을 Subselect 로 조정
>
>
> 실제로 프로젝트를 할 때에는 기본적으로 Batch Size를 조정하는 옵션을 깔아두고 Fetch Join을 사용하여 해결 한다.





# 읽기 전용 쿼리의 성능 최적화

> JPA의 성능을 최적화 하는 방법으로는 아래와 같은 방법이 있다.
>
> - 스칼라 타입으로 조회
> - 읽기 전용 쿼리 힌트 사용
> - 읽기 전용 트랜잭션 사용
> - 트랜잭션 밖에서 읽기
>
> 스프링에서는 @Transaction 에서 readOnly 옵션을 true로 하는 방법을 자주 사용한다.
>
> readOnly 옵션을 사용하면 영속성 컨텍스트가 존재하지 않아 영속성 컨텍스트가 해주는 기능이 작동하지 않는다.



# JDBC Batch 

> 동일한 쿼리를 모았다가 한번에 날리는 방식으로 DB와 통신하기 위한 네트워크 호출을 줄이며 모았다가 보내는 방식으로 인해 Lock이 적게 걸린다.



# JPA 낙관적 락

> 데이터베이스가 제공하는 락 기능을 사용하는 것이 아니라 JPA가 제공하는 버전 관리 기능을 사용한다. 
>
> 트랜잭션을 커밋하기 전까지는 트랜잭션의 충돌을 알 수 없다는 특징이 있다.
>
>
> @Version 이라는 어노테이션을 사용하여 낙관적 락을 사용한다.
>
> 



# JPA 비관적 락

> 트랜잭션의 충돌이 발생한다고 가정하고 우선 락을 걸고 보는 방법이다. 
> 데이터베이스가 제공하는 락 기능을 사용한다. 대표적으로 select for update 구문이 있다.





# JPA 락

> JPA를 사용할 때 추천하는 전략은 두 번의 갱신 내역 분실 문제 예방할 수 있는 READ COMMITTED 트랜잭션 격리 수준 + 낙관적 버전 관리다. 





# 2차 캐시

> 애플리케이션 범위의 캐시를 말한다.
>
> 2차 캐시는 동시성을 극대화하려고 캐시 한 객체를 직접 반환하지 않고 복사본을 만들어서 반환한다. 
>
> @Cacheable 을 사용한다.

![3](https://user-images.githubusercontent.com/73545607/131148404-916a7dbb-8705-45c9-b2c1-de34b993bcf5.png)

![4](https://user-images.githubusercontent.com/73545607/131148418-90205afd-6cf8-4dee-9678-b23db6e0557c.png)



# 하이버네이트 EHCACHE

> 하이터네이트에서 지원하는 캐시는 다음과 같다.
>
> - 엔티티 캐시 : 엔티티 단위로 캐시한다. 식별자로 엔티티를 조회하거나 컬렉션이 아닌 연관된 엔티티를 로딩할 때 사용한다.
> - 컬렉션 캐시 : 엔티티와 연관된 컬렉션을 캐시한다. 컬렉션이 엔티티를 담고 있으면 식별자 값만 캐시한다
> - 쿼리 캐시 : 쿼리와 파라미터 정보를 키로 사용해서 캐시한다. 결과가 엔티티면 식별자 값만 캐시한다.
>
> 보통 잘 변하지 않는 데이터에 대해서 캐시한다.
>
> 



# 쿼리 캐시와 컬렉션 캐시의 주의점

> 엔티티를 캐시하면 엔티티 정보를 모두 캐시 하지만 쿼리 캐시와 컬렉션 캐시는 결과 집합의 식별자 값만 캐시한다. 이에 따라서 N+1 문제가 발생 할 수 있기에 엔티티에는 꼭 엔티티 캐시를 적용해야 한다.
